#define _CRT_SECURE_NO_WARNINGS 1
//给定一个三位数，要求各位不能相同。
//例如，352是符合要求的，112是不符合要求的。
//将这个三位数的三个数字重新排列，得到的最大的数，减去得到的最小的数，形成一个新的三位数。
//对这个新的三位数可以重复上述过程。神奇的是，最终一定会得到495！
//试试看，重新排列352，得到的最大数为532，最小数为235，它们的差是297；
//变换297，得到972 - 279 = 693；变换693，963 - 369 = 594；
//变换594，954 - 459 = 495。
//现在，输入的三位数，通过编程得出，这个三位数经过多少次变换能够得到495吗
//好复杂的题目啊！！！！最后一题了！！！！！
//因此，352经过4次变换得到了495。
// 显然 这是个循环? 但是这个循环怎么搞？
#include <iostream>
using namespace std;
int main()
{
	int num = 0;
	cin >> num;
    int g = num % 10;            
    int s = num / 10 % 10;       
    int b = num / 100;
	int count = 0;
    if (g == s && s == b && g == b)
    {
        return 0;
    }
        while (num != 495)
        {
             g = num % 10;            // 为什么要在循环内定义：
	         s = num / 10 % 10;       //1数据更新：每次循环num都发生变化，需要重新计算各位数字
	         b = num / 100;           //2变量生命周期：循环内的变量每次循环都会重新初始化
            if (b > s)                //3逻辑正确性：确保每次使用的都是当前num的各位数字                                                       
            {                         //4避免脏数据：防止使用上一次循环的旧值
                int temp = b;
                b = s;     
                s = temp;
            }
            if (s > g)
            {
                int temp = s;
                s = g;
                g = temp;
            }
            if (b > s)
            {
                int temp = b;
                b = s;
                s = temp;
            }
            int max = 100 * g + 10 * s + b;
            int min = 100 * b + 10 * s + g;
            num = max - min;
            count++;
        }
        cout << count << endl;
	return 0;
}


